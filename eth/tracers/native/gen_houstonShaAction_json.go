// Code generated by github.com/fjl/gencodec. DO NOT EDIT.

package native

import (
	"encoding/json"

	"github.com/ledgerwatch/erigon-lib/common"
	"github.com/ledgerwatch/erigon-lib/common/hexutil"
	"github.com/ledgerwatch/erigon-lib/common/hexutility"
)

var _ = (*ShaActionMarshalling)(nil)

// MarshalJSON marshals as JSON.
func (s ShaAction) MarshalJSON() ([]byte, error) {
	type ShaAction struct {
		EventId        uint64           `json:"event_id"`
		ShaPreimage    hexutility.Bytes `json:"sha_preimage"`
		Result         hexutility.Bytes `json:"result"`
		CallId         uint64           `json:"call_id"`
		Pc             hexutil.Uint64   `json:"pc"`
		Address        common.Address   `json:"address"`
		StorageAddress common.Address   `json:"storage_address"`
	}
	var enc ShaAction
	enc.EventId = s.EventId
	enc.ShaPreimage = s.ShaPreimage
	enc.Result = s.Result
	enc.CallId = s.CallId
	enc.Pc = hexutil.Uint64(s.Pc)
	enc.Address = s.Address
	enc.StorageAddress = s.StorageAddress
	return json.Marshal(&enc)
}

// UnmarshalJSON unmarshals from JSON.
func (s *ShaAction) UnmarshalJSON(input []byte) error {
	type ShaAction struct {
		EventId        *uint64           `json:"event_id"`
		ShaPreimage    *hexutility.Bytes `json:"sha_preimage"`
		Result         *hexutility.Bytes `json:"result"`
		CallId         *uint64           `json:"call_id"`
		Pc             *hexutil.Uint64   `json:"pc"`
		Address        *common.Address   `json:"address"`
		StorageAddress *common.Address   `json:"storage_address"`
	}
	var dec ShaAction
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}
	if dec.EventId != nil {
		s.EventId = *dec.EventId
	}
	if dec.ShaPreimage != nil {
		s.ShaPreimage = *dec.ShaPreimage
	}
	if dec.Result != nil {
		s.Result = *dec.Result
	}
	if dec.CallId != nil {
		s.CallId = *dec.CallId
	}
	if dec.Pc != nil {
		s.Pc = uint64(*dec.Pc)
	}
	if dec.Address != nil {
		s.Address = *dec.Address
	}
	if dec.StorageAddress != nil {
		s.StorageAddress = *dec.StorageAddress
	}
	return nil
}
